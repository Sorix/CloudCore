//
//  CoreDataChangesListener.swift
//  CloudCore
//
//  Created by Vasily Ulianov on 02.02.17.
//  Copyright Â© 2017 Vasily Ulianov. All rights reserved.
//

import Foundation
import CoreData

/// Class responsible for taking action on Core Data save notifications
class CoreDataListener {
	var container: NSPersistentContainer
	
	let converter = ObjectToRecordConverter()
	let cloudSaveOperationQueue = CloudSaveOperationQueue()

	let cloudContextName = "CloudCoreSync"
	
	public init(container: NSPersistentContainer, errorBlock: ErrorBlock?) {
		self.container = container
		converter.errorBlock = errorBlock
		cloudSaveOperationQueue.errorBlock = errorBlock
	}
	
	/// Observe Core Data willSave and didSave notifications
	func observe() {
		NotificationCenter.default.addObserver(self, selector: #selector(self.willSave(notification:)), name: .NSManagedObjectContextWillSave, object: nil)
		NotificationCenter.default.addObserver(self, selector: #selector(self.didSave(notification:)), name: .NSManagedObjectContextDidSave, object: nil)
	}
	
	/// Remove Core Data observers
	func stopObserving() {
		NotificationCenter.default.removeObserver(self)
	}
	
	deinit {
		stopObserving()
	}
	
	@objc private func willSave(notification: Notification) {
		guard let context = notification.object as? NSManagedObjectContext else { return }
		
		// Ignore saves that are generated by FetchAndSaveController
		if context.name == CloudCore.config.contextName { return }
		
		// Upload only for changes in root context that will be saved to persistentStore
		if context.parent != nil { return }
		
		converter.setUnconfirmedOperations(inserted: context.insertedObjects,
		                                  updated: context.updatedObjects,
		                                  deleted: context.deletedObjects)
	}
	
	@objc private func didSave(notification: Notification) {
		guard let context = notification.object as? NSManagedObjectContext else { return }
		if context.name == CloudCore.config.contextName { return }
		if context.parent != nil { return }

		if converter.notConfirmedConvertOperations.isEmpty && converter.recordIDsToDelete.isEmpty { return }
		
		DispatchQueue.global(qos: .utility).async { [weak self] in
			guard let listener = self else { return }
			NotificationCenter.default.post(name: .CloudCoreWillSyncToCloud, object: nil)
			
			let backgroundContext = listener.container.newBackgroundContext()
			backgroundContext.name = listener.cloudContextName
			
			let records = listener.converter.confirmConvertOperationsAndWait(in: backgroundContext)
			listener.cloudSaveOperationQueue.addOperations(recordsToSave: records.recordsToSave, recordIDsToDelete: records.recordIDsToDelete)
			listener.cloudSaveOperationQueue.waitUntilAllOperationsAreFinished()
			
			NotificationCenter.default.post(name: .CloudCoreDidSyncToCloud, object: nil)
		}
	}
}
